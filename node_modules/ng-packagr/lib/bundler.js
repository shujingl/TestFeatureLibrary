"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assets_1 = require("./steps/assets");
var ngc_1 = require("./steps/ngc");
var sorcery_1 = require("./steps/sorcery");
var rollup_1 = require("./steps/rollup");
var tsc_1 = require("./steps/tsc");
var copy_1 = require("./util/copy");
var json_1 = require("./util/json");
/**
 * Main Angular bundling processing.
 *
 * @param entry A TypeScript source file (`*.ts`) of the bundle's entrypoint.
 * @param ngPkg Parent Angular package.
 * @returns Distribution-ready build artefacts.
 */
exports.generateNgBundle = function (entry, ngPkg) { return Promise.resolve()
    .then(function () { return assets_1.processAssets(ngPkg.src, ngPkg.workingDirectory + "/ts"); })
    .then(function () { return ngc_1.prepareTsConfig(ngPkg, ngPkg.workingDirectory + "/ts/tsconfig.lib.json")
    .then(function (tsConfigFile) { return ngc_1.ngc(tsConfigFile, ngPkg.workingDirectory + "/ts"); })
    .then(function (es2015EntryFile) {
    // XX: see #46 - ngc only references to closure-annotated ES6 sources
    return sorcery_1.remapSourcemap(ngPkg.workingDirectory + "/ts/" + ngPkg.flatModuleFileName + ".js")
        .then(function () { return Promise.resolve(es2015EntryFile); });
}); })
    .then(function (es2015EntryFile) {
    return rollup_1.rollup({
        moduleName: ngPkg.meta.name,
        entry: es2015EntryFile,
        format: 'es',
        dest: ngPkg.workingDirectory + "/" + ngPkg.artefacts.es2015,
        externals: ngPkg.libExternals
    })
        .then(function () { return sorcery_1.remapSourcemap(ngPkg.workingDirectory + "/" + ngPkg.artefacts.es2015); });
})
    .then(function () {
    return tsc_1.downlevelWithTsc(ngPkg.workingDirectory + "/" + ngPkg.artefacts.es2015, ngPkg.workingDirectory + "/" + ngPkg.artefacts.module)
        .then(function () { return sorcery_1.remapSourcemap(ngPkg.workingDirectory + "/" + ngPkg.artefacts.module); });
})
    .then(function () {
    return rollup_1.rollup({
        moduleName: ngPkg.meta.name,
        entry: ngPkg.workingDirectory + "/" + ngPkg.artefacts.module,
        format: 'umd',
        dest: ngPkg.workingDirectory + "/" + ngPkg.artefacts.main,
        externals: ngPkg.libExternals
    })
        .then(function () { return sorcery_1.remapSourcemap(ngPkg.workingDirectory + "/" + ngPkg.artefacts.main); });
})
    .then(function () { return copy_1.copyFiles(ngPkg.workingDirectory + "/" + ngPkg.meta.scope + "/**/*.{js,js.map}", ngPkg.dest + "/" + ngPkg.meta.scope); })
    .then(function () { return copy_1.copyFiles(ngPkg.workingDirectory + "/bundles/**/*.{js,js.map}", ngPkg.dest + "/bundles"); })
    .then(function () { return copy_1.copyFiles(ngPkg.workingDirectory + "/ts/**/*.{d.ts,metadata.json}", "" + ngPkg.dest); })
    .then(function () { return json_1.modifyJsonFiles(ngPkg.dest + "/**/*.js.map", function (sourceMap) {
    sourceMap['sources'] = sourceMap['sources']
        .map(function (path) { return path.replace('../ts', ngPkg.meta.scope ? "~/" + ngPkg.meta.scope + "/" + ngPkg.meta.name : "~/" + ngPkg.meta.name); });
    return sourceMap;
}); })
    .then(function () {
    return ngPkg.artefacts;
    /*
    return {
      main: '',
      module: '',
      es2015: '',
      typings: '',
      metadata: ''
    };
    */
}); };
//# sourceMappingURL=bundler.js.map